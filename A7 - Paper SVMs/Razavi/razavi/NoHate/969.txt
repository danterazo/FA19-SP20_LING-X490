Also , in your example , I would rather trust IF ( .NOT. ( X .EQ. X ) ) THEN . since I think that any comparison involving NaN always evaluates to .False. , i.e. with NaNs , X .NE. X and X .EQ. X should both return .False. Good point. This is one of the things that always bothered me about forcing unordered numbers onto two-state logic. Whats really needed is tri-state logic : X .EQ. Y , X .NE. Y , X .UNORDERED. Y Watch out for compilers that evaluate expressions like ( X .EQ. X ) to .TRUE. , ( e.g. , SGI MipsPro f90 ) . There are incantantions to force such expressions to be evaluated at run-time using IEEE semantics , but it would certainly help if the default handling of such cases defaulted to the same behaviour for all compilers. At the very least , a compiler encountering ( X .EQ. X ) when IEEE semantics are disabled should issue a warning , since few programmers would intentionally use ( X .EQ. X ) unless they wanted IEEE semantics. Bedford Inst. of Oceanography , Nova Scotia , Canada . 
